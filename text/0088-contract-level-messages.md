# Title

## Summary

[summary]: #summary

Contract level messages are a facility that enable a smart contract to emit a message while executing which eventually gets sent on the event stream and is visible from outside the network.

## Motivation

[motivation]: #motivation

Under certain conditions, a contract may want to emit a message that an off-chain application may want to listen for and react to.
Currently there is no facility for a contract to emit this type of information in a way that the message is protected from spoofing and repudiation.
Because the execution effects are sent out on the event stream, in the past some contracts tried to simulate this type of functionality by writing messages to global state and then parsing the execution effects through a user-defined convention to extract the message. This is not secure in most scenarios because there it is no way to guarantee irrefutably where the message originated from (e.g. if a contract calls another contract, it may happen that the called contract emits a malicious message instead of the caller).

In order to provide a way for contracts to be able to emit messages that will ultimately show up in a controlled way on the event stream and can be observed after the execution is complete and committed, the execution engine needs to provide a facility that will allow the message to clearly and non-repudiably state who it originated from (what entity on chain created the message); there should also be some impact on the merkle proof that is generated when the message is emitted. 

## Guide-level explanation

[guide-level-explanation]: #guide-level-explanation

From a contract point of view, the execution engine will expose new special purpose FFIs that allow for emitting messages. Two new FFIs are introduced to enable this feature:
* registering new message kinds (topics) - `casper_register_message_topic`
  * Because the host needs to create a new indexed key under which it would store the message digest, the contract is required to register its intent to emit messages beforehand by registering a new message kind (a new topic) under which it will emit messages.
  * Only a limited number of messages can be sent out by a contract.
* emitting messages - `casper_emit_message`
  * New messages are emitted under a pre-registered topic only.
  * The message emitted will be of a pre-defined message type which is an enum that will initially support sending out human readable strings but can be extended in the future to support other types.
  * The number of messages that can be emitted on a specified topic is limited by the number specified during registration of the topic. If more messages are produced, the FFI will return an error.

When a new topic is registered through the `casper_register_message_topic` FFI, the host creates a composite key derived from the callers entity address and the topic name.
This step is required in order for users to be able to verify messages later on by querying global state using a `Key` derived as mentioned above. This also allows for specifying a tighter limit on the number of messages that can be generated.

When the host receives these messages through the `casper_emit_message` FFI, the identity of the caller entity will be attached to the message.
The messages that are emitted will not be stored in global state; only a digest of the identity and the message will be however stored to global state. This allows users to verify the integrity of the message and also check that the message was indeed generated by the expected entity by doing a query to global state.
Messages will be passed by the execution engine to the node that will eventually send them out on the event stream after the execution is complete and committed.

**Note:** the messages themselves cannot be reconstructed by reading the entry from global state since that entry contains only the digest of the messages sent.

## Reference-level explanation

[reference-level-explanation]: #reference-level-explanation

The implementation for supporting contract level messages requires changes in both the execution engine and the node.

### Changes to execution engine

#### Introduce new FFIs:
```rust
/// Registers a new message topic with the specified name for the calling contract.
/// 
/// The topic name is a string of a maximum length that is specified in the chainspec.
/// Will return an error if:
///     * the topic name length is exceeded
///     * the topic size is larger than the maximum topic size specified in the chainspec
pub fn casper_register_message_topic(topic_name_ptr: *const u8, topic_name_size: usize, topic_size: usize)
```

```rust
/// Emits a new message on the specified topic.
/// 
/// The topic needs to have been already registered through a call to `casper_register_message_topic` before emitting a message.
/// 
/// Will return an error if:
///     * the maximum number of messages on this topic were exceeded
///     * the message is of type [`Message`]
///     * the length of the message is larger than the maximum length specified in the chainspec
pub fn casper_emit_message(
    topic_name_ptr: *const u8,
    topic_name_size: usize,
    message_ptr: *const u8,
    message_size: usize,
);
```

The `Message` enum initially allows for sending human readable strings as messages in the first iteration:
```rust
pub enum Message {
    String(String)
}
```

#### A new `Key` variant is introduced for indexing the message topic digests:

```rust
pub enum Key {
    ...
    /// A `Key` under which a message topic is stored
    MessageTopic(MessageAddr),
}
```

`MessageAddr` is a composite key derived from the caller's entity address and a hash of the topic name:
```rust
pub struct MessageAddr {
    /// The entity addr.
    entity_addr: HashAddr,
    /// A 32 byte BLAKE2b hash of the name of the message topic.
    topic_hash: [u8; 32],
}
```

The stored value that is written to global state under this key is a also a hash of the messages emitted on this topic:
```rust
pub struct MessageTopicSummary {
    /// number of remaining messages that can be emitted on this topic
    pub(crate) remaining_slots: u32,
    /// BLAKE2b hash of the message topic
    pub(crate) message_topic_hash: Digest,
}
```
The hash of the topic and the number of remaining slots are modified with each message that is emitted by the contract:
* the number of remaining slots is decremented
* the new topic hash is calculated by concatenating the old hash with the new message and hashing the result again.

### Node changes

The Execution engine provides a result to the node in the form of an `ExecutionResult`. In order to pass the message along to the node we need to extend the `ExecutionResults` to include the messages that were emitted during execution on both success and failure of the deploy.
The node will take the messages coming off the execution results in the `contract_runtime` component and will send them through the SSE hook as part of the `DeployProcessed` SSE event.

The `DeployProcessed` event already contains a field for the execution results. The messages will be included into the `casper_types::ExecutionResult::ExecutionResultV2` variant.

The modifications to global state that the host is making as part of emitting the message will appear in the results as a regular write transform for a new type of stored value.

## Rationale and alternatives

[rationale-and-alternatives]: #rationale-and-alternatives

As an alternative to creating a separate `Key` variant for storing the message summaries a regular `URef` could be used. Emitting messages could then piggyback on the `write` FFI by introducing a new type of stored value type. This `URef` would be granted to the entity that produced it and add it to its named keys.
The problem with this approach is that if a lot of messages are produced, the number of named keys can become too high. By default the URef would have Read-Add-Write permissions which would also be problematic because with write permission the value under that `URef` can be modified at any time. Also since URefs can be proliferated this would mean that potentially other entities could be able to change the messages checksums which again would weaken the validity check for the emitted messages.

Another way to provide discoverability of the message summaries would be for the host to create a composite key based upon the addressable entity's hash (first 32 bytes) and the message checksum (last 32 bytes). When a request for verification comes in, for the entity that emitted the message a key prefix can query for all the messages that the entity emitted and then check the tail of the key to see if the checksum match. If none of the suffixes match then it means that the message wasn't emitted. The issue with this approach is that this could possibly create an attack vector by someone asking for verification and forcing a node to go through a large number of key records that don't match with the suffix.

For passing the messages to the node an alternative to extending the `ExecutionResult` structure would be to add a new variant to the `TransformKind` enum called `Message` that will need to have the source entity address and the message string. The node would then extract the messages from the transforms. This approach has some semantic issues because the transforms represent a commit log that will be applied to the database and the messages will not actually be committed to the database. 

## Prior art

[prior-art]: #prior-art

Ethereum has a similar mechanism that allows smart contracts to emit events and write logs that can be processed by a subscribing application.
See: [Logging data from smart contracts with events](https://ethereum.org/uz/developers/tutorials/logging-events-smart-contracts/)

## Unresolved questions

[unresolved-questions]: #unresolved-questions

- Cost of registering topics and emitting messages
- Cost of upgrading contracts with registered topics
- New chainspec settings for limits
- Are there any drawbacks of having multiple messages on topics

## Future possibilities

[future-possibilities]: #future-possibilities

Nothing planned at the moment.