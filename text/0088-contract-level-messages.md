# Title

## Summary

[summary]: #summary

Contract level messages are a facility that enable a smart contract to emit a message while executing which eventually gets sent on the event stream and is visible from outside the network.

## Motivation

[motivation]: #motivation

Under certain conditions, a contract may want to emit a message that an off-chain application may want to listen for and react to.
Currently there is no facility for a contract to emit this type of information in a way that the message is protected from spoofing and repudiation.
Because the execution effects are sent out on the event stream, in the past some contracts tried to simulate this type of functionality by writing messages to global state and then parsing the execution effects through a user-defined convention to extract the message. This is not secure in most scenarios because there it is no way to guarantee irrefutably where the message originated from (e.g. if a contract calls another contract, it may happen that the called contract emits a malicious message instead of the caller).

In order to provide a way for contracts to be able to emit messages that will ultimately show up in a controlled way on the event stream and can be observed after the execution is complete and committed, the execution engine needs to provide a facility that will allow the message to clearly and non-repudiably state who it originated from (what entity on chain created the message); there should also be some impact on the merkle proof that is generated when the message is emitted. 

## Guide-level explanation

[guide-level-explanation]: #guide-level-explanation

From a contract point of view, the execution engine will expose new special purpose FFIs that allow for emitting messages. Two new FFIs are introduced to enable this feature:
* manage message topics - `casper_manage_message_topic`
  * A contract may want to organize messages it emits into multiple categories. This is useful for the situation where a contract may want to send out messages where the progression is important (e.g. a token needs to be minted before it can be transferred) but also wants to send other unrelated messages on a different channel (e.g. changing settings or administrative tasks).
  * Also because the host needs to create indexed keys under which it would store the message checksums, the contract is required to register its intent to emit messages beforehand by registering a new message kind (a new topic) under which it will emit messages.
  * The first operation supported will be the `Add` operation which allows the contract to create a new topic on which it can emit messages on.
  * The number of topics a contract can register will be limited by a chainspec value.
* emitting messages - `casper_emit_message`
  * New messages are emitted under a pre-registered topic only.
  * The message emitted will be of a pre-defined message type which is an enum that will initially support sending out human readable strings but can be extended in the future to support other types.

When a new topic is registered through the `casper_manage_message_topic` FFI, the host creates a composite key derived from the callers entity address and the hash of the topic name.
This step is required in order for users to be able to verify messages later on by querying global state using a `Key` derived as mentioned above.
When querying global state for the topic control record, users can determine the number of messages that were emitted in the block that has the timestamp specified in the control record.

When the host receives these messages through the `casper_emit_message` FFI, the identity of the caller entity will be attached to the message automatically by the host.
The messages that are emitted will not be stored in global state; only a checksum of the message will be however stored. This allows users to verify the integrity of the message and also check that the message was indeed generated by the expected entity by doing a query to global state. The entries in global state are uniquely identified by the hash of the entity that emitted the message, the hash of the topic name and the index of the message.

Messages will be passed by the execution engine to the node that will eventually send them out on the event stream after the execution is complete and committed.
The messages sent out on the event stream contain the identity of the entity that emitted the message, the topic on which the message was emitted, the index of the message within the topic and the actual message payload.

**Note:** the messages themselves cannot be reconstructed by reading the entry from global state since that entry contains only the checksum of the messages sent.

## Reference-level explanation

[reference-level-explanation]: #reference-level-explanation

The implementation for supporting contract level messages requires changes in both the execution engine and the node.

### Changes to execution engine

#### Introduce new FFIs:
```rust
/// Manages a message topic with the specified name for the calling contract.
/// 
/// The topic name is a string of a maximum length that is specified in the chainspec.
/// The initially supported operation will be `Add` that registers a new message topic.
/// Will return an error if:
///     * the topic name length is exceeded
///     * the topic already exists (in case of the Add operation)
///     * the call was made from an `Account` context. We only allow stored contracts to register messages.
pub fn casper_manage_message_topic(
        topic_name_ptr: *const u8,
        topic_name_size: usize,
        operation_ptr: *const u8,
        operation_size: usize,
    ) -> i32;
```

```rust
/// Emits a new message on the specified topic.
/// 
/// The topic needs to have been already registered through a call to `casper_manage_message_topic` before emitting a message.
/// 
/// Will return an error if:
///     * the message is not of a serialized [`MessagePayload`] type.
///     * the length of the message is larger than the maximum length specified in the chainspec
pub fn casper_emit_message(
    topic_name_ptr: *const u8,
    topic_name_size: usize,
    message_ptr: *const u8,
    message_size: usize,
);
```

The `MessagePayload` enum initially allows for sending human readable strings as messages in the first iteration:
```rust
pub enum MessagePayload {
    /// Human readable string message.
    String(String),
}
```

#### A new `Key` variant is introduced for indexing the message topic and message checksums:

```rust
pub enum Key {
    ...
    /// A `Key` under which a message topic or message checksum is stored.
    Message(MessageAddr),
}
```

`MessageAddr` is a composite key derived from the caller's entity address and a hash of the topic name:
```rust
pub struct MessageAddr {
    /// The entity addr.
    entity_addr: AddressableEntityHash,
    /// A 32 byte BLAKE2b hash of the name of the message topic.
    topic_hash: TopicNameHash,
    /// The message index. If the message index is `None`, the `MessageAddr` points to the topic control record.
    message_index: Option<u32>,
}
```

There are 2 types of stored values that are written to global state under this key.

The control record for the message topic:
```rust
pub struct MessageTopicSummary {
    /// Number of messages in this topic.
    pub(crate) message_count: u32,
    /// Block timestamp in which these messages were emitted.
    pub(crate) blocktime: BlockTime,
}
```


Checksum of the message payload that was emitted:
```rust
pub struct MessageChecksum(
    pub  [u8; 32], //a 32 byte BLAKE2b hash of the serialized `MessagePayload` that was emitted.
);
```

When a new message is emitted on a specified topic the `message_count` in the `MessageTopicSummary` record is incremented.
Messages have ephemeral nature by design. In order to not increase the size of global state in an uncontrolled manner, the message count is reset to zero with every newly emitted message that belongs to a new block and the block time is updated as well. The old message checksum entries are pruned from global state.
Off-chain applications can still query the old message checksums if required by using the state root hash of the block where the messages were emitted.

### Node changes

The Execution engine provides a result to the node in the form of an internal `ExecutionResult` data structure. In order to pass the message along to the node we need to extend the `ExecutionResults` to include the messages that were emitted during execution on both success and failure of the deploy.
The node will take the messages coming off the execution results in the `contract_runtime` component and will send them through the SSE hook as part of the `TransactionProcessed` SSE event.
The messages are extracted and only sent out the SSE event. The external facing `ExecutionResults` type from `casper-types` will not contain the messages. This is because execution results get stored in node storage. The messages have an ephemeral nature and should not be stored.

The `TransactionProcessed` SSE event will contain a `messages` field that will have an array of `Message` objects:

```rust
pub struct Message {
    /// The identity of the entity that produced the message.
    entity_addr: AddressableEntityHash,
    /// The payload of the message.
    message: MessagePayload,
    /// The name of the topic on which the message was emitted.
    topic_name: String,
    /// The hash of the name of the topic.
    topic_name_hash: TopicNameHash,
    /// Message index in the topic.
    index: u32,
}
```

The modifications to global state that the host is making as part of emitting the message will appear in the results as a regular write transform for a new type of stored value.

### Discovering message topics

There is no SSE event emitted when a new message topic is created by a contract. However some applications need to determine which message topics are available in order to be able to properly listen to the messages emitted.
In order to make this information easy to access, the `AddressableEntity` record of the contracts will contain a new field called `message_topics` that will store a map between registered topic names and the topic name hash:
```rust
pub struct MessageTopics(
    BTreeMap<String, TopicNameHash>,
);
```

### Cost of emitting messages and chainspec limits

New chainspec limits are put in place to control the behavior of contract level messages. These limits are bundled into the `wasm` config settings in the chainspec as follows:
```toml
[wasm.messages_limits]
# Maximum size of the topic name.
max_topic_name_size = 256
# Maximum number of topics that can be added for each contract.
max_topics_per_contract = 128
# Maximum size in bytes of the serialized message payload.
max_message_size = 1_024
```

Since contract level messages are handled through FFIs, the gas cost related to using the new interface is captured in the `wasm.host_function_costs` chainspec settings:
```toml
[wasm.host_function_costs]
manage_message_topic = { cost = 200, arguments = [0, 0, 0, 0] }
emit_message = { cost = 200, arguments = [0, 0, 0, 0] }
cost_increase_per_message = 50
```

The `cost_increase_per_message` parameter allows the configuration of increasing gas cost when emitting multiple messages within a single execution. In the example above, within a single execution, the first call to `casper_emit_message` will have gas cost 200, the second call will have cost 250 and each subsequent call will increase gas cost by `cost_increase_per_message`.
The next execution will start again with the same gas cost.

Storage cost will be charged based on the `wasm.storage_costs.gas_per_byte` chainspec parameter.

For each emitted message 2 records are written in global state: the topic control record and the message checksum. Writing these records incurs a fixed cost based on `gas_per_byte`.

When a new topic is added 2 records are written in global state: the topic control record and the addressable entity record that is extended with the new topic name and topic name hash. Because the topic name is variable, the cost depends on the length of the topic name.

### Upgrading contracts

When a new contract version is added the message topics registered from the previous version are carried over to the new contract automatically.
The `message_topics` of the previous `AddressableEntity` will be copied to the new one and a new control record will be written for each topic for the new entity.

## Rationale and alternatives

[rationale-and-alternatives]: #rationale-and-alternatives

As an alternative to creating a separate `Key` variant for storing the message summaries a regular `URef` could be used. Emitting messages could then piggyback on the `write` FFI by introducing a new type of stored value type. This `URef` would be granted to the entity that produced it and add it to its named keys.
The problem with this approach is that if a lot of messages are produced, the number of named keys can become too high. By default the URef would have Read-Add-Write permissions which would also be problematic because with write permission the value under that `URef` can be modified at any time. Also since URefs can be proliferated this would mean that potentially other entities could be able to change the messages checksums which again would weaken the validity check for the emitted messages.

Another way to provide discoverability of the message summaries would be for the host to create a composite key based upon the addressable entity's hash (first 32 bytes) and the message checksum (last 32 bytes). When a request for verification comes in, for the entity that emitted the message a key prefix can query for all the messages that the entity emitted and then check the tail of the key to see if the checksum match. If none of the suffixes match then it means that the message wasn't emitted. The issue with this approach is that this could possibly create an attack vector by someone asking for verification and forcing a node to go through a large number of key records that don't match with the suffix.

For passing the messages to the node an alternative to extending the `ExecutionResult` structure would be to add a new variant to the `TransformKind` enum called `Message` that will need to have the source entity address and the message string. The node would then extract the messages from the transforms. This approach has some semantic issues because the transforms represent a commit log that will be applied to the database and the messages will not actually be committed to the database. 

## Prior art

[prior-art]: #prior-art

Ethereum has a similar mechanism that allows smart contracts to emit events and write logs that can be processed by a subscribing application.
See: [Logging data from smart contracts with events](https://ethereum.org/uz/developers/tutorials/logging-events-smart-contracts/)

## Unresolved questions

[unresolved-questions]: #unresolved-questions

## Future possibilities

[future-possibilities]: #future-possibilities

Nothing planned at the moment.